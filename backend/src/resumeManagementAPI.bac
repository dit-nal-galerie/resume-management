import mysql, { OkPacket, ResultSetHeader, RowDataPacket }  from 'mysql2';

import bcrypt from 'bcrypt';
import { Request, Response } from 'express';
import { User } from '../../interfaces/User';
import { Resume } from '../../interfaces/Resume';
import config from './config/config';
import { ParamsDictionary } from 'express-serve-static-core';
import { ParsedQs } from 'qs';

class ResumeManagementAPI {
  getUserData(req: Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>, res: Response<any, Record<string, any>>): void | Promise<void> {
    throw new Error('Method not implemented.');
  }
  private db: mysql.Connection;

  constructor() {
    this.db = mysql.createConnection({
      host: config.DB_HOST,
      user: config.DB_USER,
      password: config.DB_PASSWORD,
      database: config.DB_NAME,
    });
  }
async createAccount(loginname: string, password: string): Promise<number | null> {
  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const query = 'INSERT INTO authentification (loginname, password) VALUES (?, ?)';
    
    return new Promise((resolve, reject) => {
      this.db.query(query, [loginname, hashedPassword], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve((result as OkPacket).insertId);
        }
      });
    });
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–∞—Ä–æ–ª—è:", error);
    return null;
  }
}

async createUser(req: Request, res: Response): Promise<void> {
  const {
    loginname,
    password,
    name,
    email,
    anrede,
    city,
    street,
    houseNumber,
    postalCode,
    phone,
    mobile,
  }: User = req.body;

  if (!loginname || !password || !email  ) {
    res.status(400).send('–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã.');
    return;
  }

  const checkQuery = `
    SELECT COUNT(*) AS count FROM authentification WHERE loginname = ? 
    UNION ALL 
    SELECT COUNT(*) AS count FROM users WHERE email = ?`;

  this.db.query(checkQuery, [loginname, email], async (err, results) => {
    if (err) {
      res.status(500).send('–û—à–∏–±–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.');
      return;
    }

    if (results[0].count > 0 || results[1].count > 0) {
      res.status(409).send('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.');
      return;
    }

    try {
      const loginid = await this.createAccount(loginname, password);
      if (!loginid) {
        res.status(500).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏.');
        return;
      }

      const userQuery = `
        INSERT INTO users (loginid, name, email, anrede, city, street, houseNumber, postalCode, phone, mobile)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

      this.db.query(userQuery, [loginid, name, email, anrede, city, street, houseNumber, postalCode, phone, mobile], (userErr) => {
        if (userErr) {
          res.status(500).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.'+userErr.message);
          return;
        }
        res.status(201).send('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω.');
      });

    } catch (error) {
      res.status(500).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞.');
    }
  });
}
  // –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã API (–ø—Ä–∏–º–µ—Ä)
  async login(req: Request, res: Response): Promise<void> {
    const { loginname, password } = req.body;
    const queryAuth = "SELECT id, password FROM authentification WHERE loginname = ?";
  
    this.db.query(queryAuth, [loginname], async (err, authResults) => {
      if (err) {
        console.error("Fehler beim Abrufen der Login-Daten:", err);
        res.status(500).send("Serverfehler.");
        return;
      }
  
      const authRows = authResults as RowDataPacket[];
  
      if (authRows.length === 0) {
        res.status(404).json({ message: "Benutzer nicht gefunden." });
        return;
      }
  
      const hashedPassword = authRows[0].password;
      const isPasswordValid = await bcrypt.compare(password, hashedPassword);
  
      if (!isPasswordValid) {
        res.status(401).json({ message: "Falsches Passwort." });
        return;
      }
  
      const loginid = authRows[0].id;
  /*
  export interface User {
    loginid: number;
    loginname: string;
    password?: string;
    password2?: string; // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–µ
    name: string;
    email: string;
    anrede: number;
    city: string;
    street: string;
    houseNumber: string;
    postalCode: string;
    phone?: string;
    mobile?: string;
    
  }
  */
      // üîπ Nutzerinformationen aus der `users`-Tabelle abrufen
      const queryUser = `
      SELECT a.loginname, u.loginid, u.name, u.email, u.anrede, u.city, u.street, u.houseNumber, u.postalCode, u.phone, u.mobile 
      FROM users u
      JOIN authentification  a ON u.loginid = a.id
      WHERE u.loginid = ?`;
    
  
      this.db.query(queryUser, [loginid], (userErr, userResults) => {
        if (userErr) {
          console.error("Fehler beim Abrufen der Benutzerinformationen:", userErr);
          res.status(500).send("Fehler beim Laden der Nutzerdaten.");
          return;
        }
  
        const userRows = userResults as RowDataPacket[];
  
        if (userRows.length === 0) {
          res.status(404).json({ message: "Benutzerinformationen nicht gefunden." });
          return;
        }
  
        // ‚úÖ Erfolgreicher Login ‚Üí Senden der vollst√§ndigen Benutzerinformationen
        res.json(userRows[0]);
      });
    });
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async updateUserData(req: Request, res: Response): Promise<void> {
    //const { loginId } = req.params;
    const { loginid , name, email, city, street, houseNumber, postalCode, phone, mobile, password } = req.body;

    // üîπ 1. Pr√ºfen, ob `userid` und `email` vorhanden sind
    if (!loginid || !email) {
      res.status(400).send("Alle Pflichtfelder m√ºssen ausgef√ºllt sein.");
      return;
    }
  
    // üîπ 2. Pr√ºfen, ob der Nutzer existiert und das Passwort korrekt ist
    const checkUserQuery = "SELECT id, password FROM authentification WHERE id = ?";
    this.db.query(checkUserQuery, [loginid], async (err, results) => {
      if (err) {
        console.error("Fehler beim Abrufen des Nutzers:", err.message);
        res.status(500).send(`Fehler beim Abrufen des Nutzers: ${err.message}`);
        return;
      }
  
      const userRows = results as RowDataPacket[];
      if (userRows.length === 0) {
        res.status(404).send("Nutzer nicht gefunden.");
        return;
      }
  
      // üîπ Passwortpr√ºfung
      const hashedPassword = userRows[0].password;
      const isPasswordValid = await bcrypt.compare(password, hashedPassword);
  
      if (!isPasswordValid) {
        res.status(401).send("Ung√ºltiges Passwort.");
        return;
      }
  
      // üîπ 3. Pr√ºfen, ob die neue `email` bereits vergeben ist
      const checkEmailQuery = "SELECT COUNT(*) AS count FROM users WHERE email = ? AND loginid <> ?";
      this.db.query(checkEmailQuery, [email, loginid], (emailErr, emailResults) => {
        if (emailErr) {
          console.error("Fehler beim √úberpr√ºfen der E-Mail:", emailErr.message);
          res.status(500).send(`Fehler beim √úberpr√ºfen der E-Mail: ${emailErr.message}`);
          return;
        }
  
        const emailRows = emailResults as RowDataPacket[];
        if (emailRows[0]?.count > 0) {
          res.status(409).send("Diese E-Mail ist bereits vergeben.");
          return;
        }
  
        // üîπ 4. Nutzerinformationen aktualisieren
        const updateQuery = `
          UPDATE users 
          SET name = ?, email = ?, city = ?, street = ?, houseNumber = ?, postalCode = ?, phone = ?, mobile = ?
          WHERE loginid = ?`;
  
        this.db.query(updateQuery, [name, email, city, street, houseNumber, postalCode, phone, mobile, loginid], (updateErr) => {
          if (updateErr) {
            console.error("Fehler beim Aktualisieren der Daten:", updateErr.message);
            res.status(500).send(`Fehler beim Aktualisieren der Daten: ${updateErr.message}`);
            return;
          }
  
          res.status(200).send("‚úÖ Nutzerdaten erfolgreich aktualisiert.");
        });
      });
    });
  }
  // –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—é–º–µ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
  async getResumesWithUsers(req: Request, res: Response): Promise<void> {
    const { userid } = req.query; // Erwartet userid aus Request
  console.log("userid", userid)
    // Falls kein userid vorhanden ist, Fehler zur√ºckgeben
    if (!userid) {
      res.status(400).send("Fehlende Nutzer-ID.");
      return;
    }
  
    const query = `
     SELECT 
    r.resumeid AS resume_id, 
    r.position, 
    r.created, 
    COALESCE(
        (SELECT s.text FROM history h
         JOIN states s ON h.stateid = s.stateid
         WHERE h.resumeid = r.resumeid
         ORDER BY h.date DESC LIMIT 1),
        'Kein Status'
    ) AS status,  
    c1.name AS company_name,  
    c2.name AS parent_company_name  
FROM resumes r
LEFT JOIN companies c1 ON r.companyid = c1.companyId
LEFT JOIN companies c2 ON r.parentcompanyid = c2.companyId
WHERE r.ref = ?;
    `;
  
    // Query ausf√ºhren mit prepared statement
    this.db.query(query, [userid], (err, results) => {
      if (err) {
        console.error("Fehler beim Abrufen der Bewerbungen:", err);
        res.status(500).send("Serverfehler.");
        return;
      }
  
      res.json(results);
    });
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–∞–∫—Ç–∞
  async addContact(req: Request, res: Response): Promise<void> {
    const { name, anrede, ref, email } = req.body;

    if (!name || !anrede || !ref || !email) {
      res.status(400).send('–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã.');
      return;
    }

    const query = 'INSERT INTO contacts (name, anrede, ref, email) VALUES (?, ?, ?, ?)';
    this.db.query(query, [name, anrede, ref, email], (err) => {
      if (err) {
        res.status(500).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞.');
        return;
      }

      res.status(201).send('–ö–æ–Ω—Ç–∞–∫—Ç —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω.');
    });
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–æ–º–ø–∞–Ω–∏–∏
  async addCompany(req: Request, res: Response): Promise<void> {
    const { name, adress, ref } = req.body;

    if (!name || !adress || !ref) {
      res.status(400).send('–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã.');
      return;
    }

    const query = 'INSERT INTO companies (name, adress, ref) VALUES (?, ?, ?)';
    this.db.query(query, [name, adress, ref], (err) => {
      if (err) {
        res.status(500).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–º–ø–∞–Ω–∏–∏.');
        return;
      }

      res.status(201).send('–ö–æ–º–ø–∞–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞.');
    });
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏
  async addHistory(req: Request, res: Response): Promise<void> {
    const { resume_id, description } = req.body;

    if (!resume_id || !description) {
      res.status(400).send('–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã.');
      return;
    }

    const query = 'INSERT INTO history (resume_id, description) VALUES (?, ?)';
    this.db.query(query, [resume_id, description], (err) => {
      if (err) {
        res.status(500).send('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏—Å—Ç–æ—Ä–∏–∏.');
        return;
      }

      res.status(201).send('–ò—Å—Ç–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞.');
    });
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–∑—é–º–µ
  async updateOrCreateResume(req: Request, res: Response): Promise<void> {
    const resume: Resume = req.body;
    console.log("üîπ Empfangenes Resume-Objekt:", resume);
  
    if (!resume.userid) {
      res.status(400).send("Resume-ID und User-ID sind erforderlich.");
      return;
    }
  
    if (resume.resumeid === 0) {
      // üîπ Neue Bewerbung erstellen
      const insertResumeQuery = `
        INSERT INTO resumes (ref, position, stateid, link, comment, companyid, parentcompanyid, created) 
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW())`;
  
      this.db.query(
        insertResumeQuery,
        [
          resume.userid,
          resume.position,
          resume.stateid,
          resume.link,
          resume.comment,
          resume.companyid === 0 ? null : resume.companyid,
          resume.parentcompanyid === 0 ? null : resume.parentcompanyid
        ],
        (err, result) => {
          if (err) {
            console.error("‚ùå Fehler beim Erstellen der Bewerbung:", err.message);
            res.status(500).send(`Fehler beim Erstellen der Bewerbung: ${err.message}`);
            return;
          }
  
          if ("insertId" in result) {
            const newResumeId = (result as ResultSetHeader).insertId;
  
            // üîπ Erste Status√§nderung in `history` speichern
            const insertHistoryQuery = `
              INSERT INTO history (resumeid, date, stateid) 
              VALUES (?, NOW(), ?)`;
  
            this.db.query(insertHistoryQuery, [newResumeId, resume.stateid], (historyErr) => {
              if (historyErr) {
                console.error("‚ùå Fehler beim Speichern in History:", historyErr.message);
                res.status(500).send(`Fehler beim Speichern in History: ${historyErr.message}`);
                return;
              }
  
              res.status(201).send("‚úÖ Neue Bewerbung erfolgreich gespeichert.");
            });
          } else {
            res.status(500).send("‚ùå Fehler: Konnte keine neue Resume-ID ermitteln.");
          }
        }
      );
    } else {
      // üîπ Bestehende Bewerbung aktualisieren
      const updateQuery = `
        UPDATE resumes 
        SET position = ?, stateid = ?, link = ?, comment = ?, companyid = ?, parentcompanyid = ? 
        WHERE resumeid = ? AND userid = ?`;
  
      console.log("üîπ Ausgef√ºhrte SQL-Query:", updateQuery);
      console.log("üîπ Parameter:", resume.position, resume.stateid, resume.link, resume.comment, resume.companyid, resume.parentcompanyid, resume.resumeid, resume.userid);
  
      this.db.query(
        updateQuery,
        [
          resume.position,
          resume.stateid,
          resume.link,
          resume.comment,
        // resume.companyid === null || resume.companyid === 0 ? null : resume.companyid,
         // resume.parentcompanyid === 0 ? null : resume.parentcompanyid,
         null, null,
          resume.resumeid,
          resume.userid
        ],
        (err) => {
          if (err) {
            console.error("‚ùå Fehler beim Aktualisieren der Bewerbung:", err.message);
            res.status(500).send(`Fehler beim Aktualisieren der Bewerbung: ${err.message}`);
            return;
          }
  
          res.status(200).send("‚úÖ Bewerbung erfolgreich aktualisiert.");
        }
      );
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π (Anrede)
  async getAnrede(req: Request, res: Response): Promise<void> {
    const query = 'SELECT * FROM anrede';
    this.db.query(query, (err, results) => {
      if (err) {
        res.status(500).send('–û—à–∏–±–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.');
        return;
      }

      res.json(results);
    });
  }

  async getResumeById(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
  
    if (!id) {
      res.status(400).send("Fehlende Resume-ID.");
      return;
    }
  
    // Wenn ID == 0 ‚Üí Leere Bewerbung zur√ºckgeben
    if (id === "0") {
      res.json({
        resume_id: 0,
        position: "",
        created: new Date().toISOString().slice(0, 10), // Aktuelles Datum
        stateid: null,
        comment: "",
        companyid: 0,
        parentcompanyid: 0,
      });
      return;
    }
  
    const query = `
      SELECT r.*
      FROM resumes r
      WHERE r.resumeid = ?;
    `;
  
    this.db.query(query, [id], (err, results) => {
      if (err) {
        console.error("Fehler beim Abrufen der Bewerbung:", err);
        res.status(500).send("Serverfehler.");
        return;
      }
  
      if (!Array.isArray(results) || results.length === 0) {
        res.status(404).send("Keine Bewerbung gefunden.");
        return;
      }
  
      res.json(results[0]);
    });
  }

  async getStates(req: Request, res: Response): Promise<void> {
    const query = "SELECT stateid, text FROM states ORDER BY stateid ASC";
  
    this.db.query(query, (err, results) => {
      if (err) {
        console.error("Fehler beim Abrufen der Status:", err);
        res.status(500).send("Serverfehler.");
        return;
      }
  
      res.json(results);
    });
  }
  async createOrUpdateContact(req: Request, res: Response): Promise<void> {
    try {
      const {
        contactid = 0,
        vorname,
        name,
        email,
        anrede,
        title,
        zusatzname,
        phone,
        mobile,
        company,
        ref,
      } = req.body;
  
      // Validierung: Pflichtfelder pr√ºfen
      if (!vorname || !name || !email || !anrede || !company || !ref) {
        res.status(400).json({ message: "Fehlende Pflichtfelder." });
        return;
      }
  
      // Pr√ºfen, ob Kontakt aktualisiert oder neu erstellt werden soll
      if (contactid === 0) {
        // Neuer Kontakt hinzuf√ºgen
        const insertQuery = `
          INSERT INTO contacts (vorname, name, email, anrede, title, zusatzname, phone, mobile, company, ref)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        this.db.query(insertQuery, [vorname, name, email, anrede, title, zusatzname, phone, mobile, company, ref], (err) => {
          if (err) {
            console.error("Fehler beim Hinzuf√ºgen des Kontakts:", err);
            res.status(500).json({ message: "Serverfehler beim Hinzuf√ºgen des Kontakts." });
            return;
          }
          res.status(201).json({ message: "Kontakt erfolgreich hinzugef√ºgt." });
        });
      } else {
        // Bestehenden Kontakt aktualisieren
        const updateQuery = `
          UPDATE contacts
          SET vorname = ?, name = ?, email = ?, anrede = ?, title = ?, zusatzname = ?, phone = ?, mobile = ?, company = ?, ref = ?
          WHERE contactid = ?
        `;
        this.db.query(updateQuery, [vorname, name, email, anrede, title, zusatzname, phone, mobile, company, ref, contactid], (err) => {
          if (err) {
            console.error("Fehler beim Aktualisieren des Kontakts:", err);
            res.status(500).json({ message: "Serverfehler beim Aktualisieren des Kontakts." });
            return;
          }
          res.status(200).json({ message: "Kontakt erfolgreich aktualisiert." });
        });
      }
    } catch (error) {
      console.error("Fehler in createOrUpdateContact:", error);
      res.status(500).json({ message: "Serverfehler beim Speichern des Kontakts." });
    }
  }
  
}

export default ResumeManagementAPI;